//
// Created by peter on 3/21/24.
//

#include <random>

#include "sorter/sample_sort.h"
#include "utils/random_number_generator.h"

/**
 * Compare the result of an in-memory sorting algorithm to an external memory sorting algorithm.
 *
 * @tparam T The type of data being sorted.
 * @tparam Iterator An iterator for the result of the in-memory sorting algorithm.
 * @param start Starting iterator
 * @param end Ending iterator
 * @param file_list A list of files resulting from the sorting algorithm
 */
template<typename T, typename Iterator>
void CompareSortingResult(Iterator start, Iterator end, const std::vector<FileInfo> &file_list) {
    auto cur = start;
    size_t cur_index = 0;
    size_t mismatch_count = 0;
    // read each file and then compare the content of the file to the result of the in-memory sorting algorithm
    for (const auto &f: file_list) {
        auto current_file = (T *) ReadEntireFile(f.file_name, f.true_size);
        size_t n = f.true_size / sizeof(T);
        for (size_t i = 0; i < n; i++) {
            if (cur == end) {
                LOG(ERROR) << "Iterator for in-memory result has unexpectedly ended at index " << cur_index;
                goto too_many_errors;
            }
            auto expected = *cur;
            auto actual = current_file[i];
            if (expected != actual) {
                LOG(ERROR) << "Mismatch at index " << cur_index << ". Expected " << expected << ". Got " << actual;
                mismatch_count++;
                if (mismatch_count >= 20) {
                    goto too_many_errors;
                }
            }
            cur++;
            cur_index++;
        }
        free(current_file);
    }
    if (cur != end) {
        LOG(ERROR) << "Expecting more numbers from files but got none.";
        return;
    }
    if (mismatch_count == 0) {
        LOG(INFO) << "No mismatch found after comparing " << cur_index << " elements.";
    }
    return;
    too_many_errors:
    LOG(ERROR) << "Too many errors. Exiting...";
    exit(0);
}

/**
 * This is a more cluncky testing function. Don't read this.
 */
void TestSampleSort() {
    using Type = uint64_t;
    std::string input_prefix = "numbers";
    std::string output_prefix = "sorted_numbers";
    LOG(INFO) << "Generating random numbers and writing them to disk";
    auto nums = GenerateUniformRandomNumbers<Type>(input_prefix, 1 << 20);
    // in memory sorting
    LOG(INFO) << "Performing in-memory sorting";
    auto all_nums = parlay::flatten(parlay::map(parlay::iota(nums.size()), [&](size_t i) {
        return parlay::sequence<Type>(nums[i].first.get(), nums[i].first.get() + nums[i].second);
    }));
    parlay::sort_inplace(all_nums, std::less<>());
    // external memory sorting
    LOG(INFO) << "Performing external memory sorting";
    SampleSort<Type> sorter;
    auto input_files = FindFiles(input_prefix);
    auto result_files = sorter.Sort(input_files, output_prefix, std::less<>());

    LOG(INFO) << "Comparing result";
    CompareSortingResult<size_t>(all_nums.begin(), all_nums.end(), result_files);
}

void nop(void* ptr) {}

/**
 * Write some small numbers to disk for testing purposes.
 *
 * @param prefix The prefix of the names of the resulting files
 * @param n Number of items to be generated
 * @return A pointer to the resulting numbers
 */
std::shared_ptr<size_t> GenerateSmallSample(const std::string &prefix, size_t n) {
    auto nums = (size_t *) malloc(n * sizeof(size_t));
    {
        auto perm = parlay::random_permutation(n);
        parlay::parallel_for(0, n, [&](size_t i) {
            nums[i] = perm[i];
        });
    }
    UnorderedFileWriter<size_t> writer(prefix);
    size_t step = std::min(1UL << 20, n);
    for (size_t i = 0; i < n; i += step) {
        writer.Push(std::shared_ptr<size_t>(nums + i, nop), std::min(step, n - i));
    }
    writer.Close();
    writer.Wait();
    parlay::parallel_for(0, n, [&](size_t i) {
        nums[i] = i;
    });
    return {nums, free};
}

std::shared_ptr<size_t> GetDummyArray(size_t n = 4096) {
    std::shared_ptr<size_t> result((size_t *) malloc(n * sizeof(size_t)), free);
    for (size_t i = 0; i < n; i++) {
        result.get()[i] = i + 1;
    }
    return result;
}

/**
 * Test the sorter with a small data sample
 * @param n Number of items in the test
 */
void TestSampleSortSmall(size_t n, bool generate) {
    const std::string prefix = "numbers", result_prefix = "result";
    std::shared_ptr<size_t> nums;
    if (generate) {
        nums = GenerateSmallSample(prefix, n);
    } else {
        nums = GetDummyArray(n);
    }
    SampleSort<size_t> sorter;
    // Note that we don't know the number of files in the list. We just know the prefix.
    // We need to look for the files generated by GenerateSmallSample.
    auto file_list = FindFiles(prefix);
    LOG(INFO) << "Performing external memory sort.";
    auto result_files = sorter.Sort(file_list, result_prefix, std::less<>());
    LOG(INFO) << "Comparing sorting result.";
    CompareSortingResult<size_t>(nums.get(), nums.get() + n, result_files);
}

int main(int argc, char **argv) {
    if (argc < 3) {
        show_usage:
        LOG(ERROR) << "Usage: " << argv[0] << " <data size> <true|false>";
        return 0;
    }
    auto n = std::atol(argv[1]);
    bool regenerate;
    if (strcmp(argv[2], "true") == 0) {
        regenerate = true;
    } else if (strcmp(argv[2], "false") == 0) {
        regenerate = false;
    } else {
        goto show_usage;
    }
    LOG(INFO) << "Testing with size " << n << " and generate: " << regenerate;
    TestSampleSortSmall(n, regenerate);
}
